/* === EXTENSIONS === */

BEGIN;

CREATE EXTENSION IF NOT EXISTS CITEXT;
CREATE EXTENSION IF NOT EXISTS PG_TRGM;

/* === DOMAINS === */

CREATE DOMAIN EMAIL AS CITEXT
  CHECK (
    value ~ '^[a-zA-Z0-9.!#$%&''*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$'
    AND
    value IS NOT NULL
  );

CREATE DOMAIN REQUIRED_TEXT AS TEXT NOT NULL;

CREATE DOMAIN REQUIRED_FK AS BIGINT NOT NULL;

CREATE DOMAIN CURRENCY AS DECIMAL(12, 2)
  DEFAULT 0
  CHECK (value >= 0 AND value IS NOT NULL);

CREATE DOMAIN ENTITY_TIMESTAMP AS TIMESTAMPTZ
  DEFAULT CURRENT_TIMESTAMP;

/* === ENTITIES === */

CREATE TABLE USERS (
  USER_ID BIGINT GENERATED ALWAYS AS IDENTITY CONSTRAINT USERS_PK_USERID PRIMARY KEY,
  USER_NAME REQUIRED_TEXT,
  USER_EMAIL EMAIL,
  USER_PASSWORD REQUIRED_TEXT,
  CREATED_AT ENTITY_TIMESTAMP,
  UPDATED_AT ENTITY_TIMESTAMP
);

CREATE TABLE CATEGORIES (
  CATEGORY_ID BIGINT GENERATED ALWAYS AS IDENTITY CONSTRAINT CATEGORIES_PK_CATEGORYID PRIMARY KEY,
  CATEGORY_NAME REQUIRED_TEXT,
  CATEGORY_DESCRIPTION TEXT,
  CATEGORY_IMAGE TEXT,
  CREATED_AT ENTITY_TIMESTAMP,
  UPDATED_AT ENTITY_TIMESTAMP
);

CREATE TABLE PRODUCTS (
  PRODUCT_ID BIGINT GENERATED ALWAYS AS IDENTITY CONSTRAINT PRODUCTS_PK_PRODUCTID PRIMARY KEY,
  PRODUCT_NAME REQUIRED_TEXT,
  PRODUCT_DESCRIPTION REQUIRED_TEXT,
  PRODUCT_SKU REQUIRED_TEXT,
  PRODUCT_IMAGE REQUIRED_TEXT,
  PRODUCT_PRICE CURRENCY,
  PRODUCT_QUANTITY INTEGER CONSTRAINT PRODUCTS_CK_QTY CHECK (PRODUCT_QUANTITY >= 0 AND PRODUCT_QUANTITY IS NOT NULL),
  CREATED_AT ENTITY_TIMESTAMP,
  UPDATED_AT ENTITY_TIMESTAMP,
  CATEGORY_ID REQUIRED_FK,

  CONSTRAINT PRODUCTS_CATEGORIES_FK_CATEGORYID FOREIGN KEY (CATEGORY_ID) REFERENCES CATEGORIES (CATEGORY_ID) ON DELETE CASCADE
);

CREATE TABLE USER_INFO (
  INFO_ID BIGINT GENERATED ALWAYS AS IDENTITY CONSTRAINT INFO_PK_INFOID PRIMARY KEY,
  INFO_STREET REQUIRED_TEXT,
  INFO_APT TEXT,
  INFO_CITY REQUIRED_TEXT,
  INFO_PROVINCE REQUIRED_TEXT,
  INFO_PHONE TEXT CONSTRAINT INFO_CK_INFOPHONE CHECK (INFO_PHONE ~ '^\(?([0-9]{3})\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$'),
  CREATED_AT ENTITY_TIMESTAMP,
  UPDATED_AT ENTITY_TIMESTAMP,
  USER_ID REQUIRED_FK,

  CONSTRAINT INFO_USERS_FK_USERID FOREIGN KEY (USER_ID) REFERENCES USERS (USER_ID) ON DELETE CASCADE
);

CREATE TABLE COMMENTS (
  COMMENT_ID BIGINT GENERATED ALWAYS AS IDENTITY CONSTRAINT COMMENTS_PK_INFOID PRIMARY KEY,
  COMMENT_CONTENT REQUIRED_TEXT,
  COMMENT_LIKES BIGINT DEFAULT 0,
  COMMENT_DISLIKES BIGINT DEFAULT 0,
  CREATED_AT ENTITY_TIMESTAMP,
  UPDATED_AT ENTITY_TIMESTAMP,
  USER_ID REQUIRED_FK,
  PRODUCT_ID REQUIRED_FK,

  CONSTRAINT COMMENTS_USERS_FK_USERID FOREIGN KEY (USER_ID) REFERENCES USERS (USER_ID) ON DELETE CASCADE,
  CONSTRAINT COMMENTS_PRODUCTS_FK_PRODUCTID FOREIGN KEY (PRODUCT_ID) REFERENCES PRODUCTS (PRODUCT_ID) ON DELETE CASCADE
);

CREATE TABLE INVOICES (
  INVOICE_ID BIGINT GENERATED ALWAYS AS IDENTITY CONSTRAINT INVOICES_PK_INVOICEID PRIMARY KEY,
  INVOICE_PRICE CURRENCY,
  INVOICE_VALID BOOLEAN DEFAULT FALSE,
  CREATED_AT ENTITY_TIMESTAMP,
  UPDATED_AT ENTITY_TIMESTAMP,
  USER_ID REQUIRED_FK,

  CONSTRAINT INVOICES_USERS_FK_USERID FOREIGN KEY (USER_ID) REFERENCES USERS (USER_ID) ON DELETE CASCADE
);

CREATE TABLE ORDERS (
  ORDER_ID BIGINT GENERATED ALWAYS AS IDENTITY CONSTRAINT ORDERS_PK_ORDERID PRIMARY KEY,
  ORDER_QUANTITY INTEGER CONSTRAINT PRODUCTS_CK_QTY CHECK (ORDER_QUANTITY >= 0 AND ORDER_QUANTITY IS NOT NULL),
  ORDER_UNITPRICE CURRENCY,
  ORDER_TOTALPRICE CURRENCY GENERATED ALWAYS AS (ORDER_QUANTITY * ORDER_UNITPRICE) STORED, 
  CREATED_AT ENTITY_TIMESTAMP,
  UPDATED_AT ENTITY_TIMESTAMP,
  INVOICE_ID REQUIRED_FK,
  PRODUCT_ID REQUIRED_FK,

  CONSTRAINT ORDERS_INVOICES_FK_INVOICEID FOREIGN KEY (INVOICE_ID) REFERENCES INVOICES (INVOICE_ID) ON DELETE CASCADE,
  CONSTRAINT ORDERS_PRODUCTS_FK_PRODUCTID FOREIGN KEY (PRODUCT_ID) REFERENCES PRODUCTS (PRODUCT_ID) ON DELETE CASCADE
);

COMMIT;

/* === INDICES === */

CREATE UNIQUE INDEX IDX_USERS_USEREMAIL ON USERS(USER_EMAIL);

CREATE UNIQUE INDEX IDX_CATEGORIES_CATEGORYNAME ON CATEGORIES(CATEGORY_NAME);

CREATE INDEX IDX_PRODUCTS_PRODUCTNAME ON PRODUCTS(PRODUCT_NAME);

/* === FUNCTIONS === */

CREATE OR REPLACE FUNCTION UPDATE_TIMESTAMP()
RETURNS TRIGGER AS $$
BEGIN
  NEW.UPDATED_AT = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';

CREATE OR REPLACE FUNCTION SYNC_INVOICE_PRICE()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE INVOICES
  SET INVOICE_PRICE = INVOICE_PRICE + (NEW.ORDER_UNITPRICE * NEW.ORDER_TOTALPRICE)
  WHERE INVOICE_ID = NEW.INVOICE_ID;
END;
$$ LANGUAGE 'plpgsql';

/* PROCEDURES */

CREATE OR REPLACE PROCEDURE SEEDING(
  IN CATEGORY_NAME_IN TEXT,
  IN PRODUCT_NAME_IN TEXT,
  IN PRODUCT_DESCRIPTION_IN TEXT,
  IN PRODUCT_SKU_IN TEXT,
  IN PRODUCT_IMAGE_IN TEXT,
  IN PRODUCT_PRICE_IN DECIMAL
)
AS $$
DECLARE
  CAT_ID BIGINT;
BEGIN
  -- Look for Category
  SELECT CATEGORY_ID FROM CATEGORIES WHERE CATEGORY_NAME = CATEGORY_NAME_IN INTO CAT_ID;

  -- CREATE PRODUCT
  INSERT INTO PRODUCTS
  (PRODUCT_NAME, PRODUCT_DESCRIPTION, PRODUCT_SKU, PRODUCT_IMAGE, PRODUCT_PRICE, PRODUCT_QUANTITY, CATEGORY_ID)
  VALUES
  (PRODUCT_NAME_IN, PRODUCT_DESCRIPTION_IN, PRODUCT_SKU_IN, PRODUCT_IMAGE_IN, PRODUCT_PRICE_IN, 99999, CAT_ID);
END;
$$ LANGUAGE 'plpgsql';

/* === TRIGGERS === */

BEGIN;

-- TIMESTAMP TRIGGERS

CREATE TRIGGER TRG_UPDATE_USER_TIMESTAMP
BEFORE UPDATE
ON USERS
FOR EACH ROW
EXECUTE PROCEDURE UPDATE_TIMESTAMP();

CREATE TRIGGER TRG_UPDATE_CATEGORIES_TIMESTAMP
BEFORE UPDATE
ON CATEGORIES
FOR EACH ROW
EXECUTE PROCEDURE UPDATE_TIMESTAMP();

CREATE TRIGGER TRG_UPDATE_PRODUCTS_TIMESTAMP
BEFORE UPDATE
ON PRODUCTS
FOR EACH ROW
EXECUTE PROCEDURE UPDATE_TIMESTAMP();

CREATE TRIGGER TRG_UPDATE_INFO_TIMESTAMP
BEFORE UPDATE
ON USER_INFO
FOR EACH ROW
EXECUTE PROCEDURE UPDATE_TIMESTAMP();

CREATE TRIGGER TRG_UPDATE_COMMENTS_TIMESTAMP
BEFORE UPDATE
ON COMMENTS
FOR EACH ROW
EXECUTE PROCEDURE UPDATE_TIMESTAMP();

CREATE TRIGGER TRG_UPDATE_INVOICES_TIMESTAMP
BEFORE UPDATE
ON INVOICES
FOR EACH ROW
EXECUTE PROCEDURE UPDATE_TIMESTAMP();

CREATE TRIGGER TRG_UPDATE_ORDERS_TIMESTAMP
BEFORE UPDATE
ON ORDERS
FOR EACH ROW
EXECUTE PROCEDURE UPDATE_TIMESTAMP();

-- INVOICE : ORDER PRICE SYNC TRIGGER

CREATE TRIGGER TRG_SYNC_INVOICE_ORDER_PRICE
BEFORE UPDATE
ON ORDERS
FOR EACH ROW
EXECUTE PROCEDURE SYNC_INVOICE_PRICE();

COMMIT;